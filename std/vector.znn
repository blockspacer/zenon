
public embed {

#include <vector>
using std::vector;
#include <algorithm>
template <typename T>
using vector_iterator = typename vector<T>::const_iterator;
template <typename T>
using vector_mut_iterator = typename vector<T>::iterator;
}

public import "std/concepts.znn";

public template <T>
extern struct vector;

public template <T>
extern vector();

public template <T>
extern struct vector_iterator;

public template <T>
extern struct vector_mut_iterator;

public template <T>
vector_iterator<T> begin(vector<T>* v) {
  embed {
    return v->begin();
  }
}

public template <T>
vector_iterator<T> end(vector<T>* v) {
  embed {
    return v->end();
  }
}

public template <T>
T* operator *(vector_iterator<T>* it) {
  embed {
    return &**it;
  }
}

public template <T>
vector_iterator<T> operator ++(vector_iterator<T> mutable* it) {
  embed {
    return ++(*it);
  }
}

public template <T>
bool operator == (vector_iterator<T>* it1, vector_iterator<T>* it2) {
  embed {
    return *it1 == *it2;
  }
}

public template <T>
vector_mut_iterator<T> begin(vector<T> mutable* v) {
  embed {
    return v->begin();
  }
}

public template <T>
vector_mut_iterator<T> end(vector<T> mutable* v) {
  embed {
    return v->end();
  }
}


public template <T>
T mutable* operator *(vector_mut_iterator<T>* it) {
  embed {
    return &**it;
  }
}

public template <T>
vector_mut_iterator<T> operator ++(vector_mut_iterator<T> mutable* it) {
  embed {
    return ++(*it);
  }
}

public template <T>
bool operator == (vector_mut_iterator<T>* it1, vector_mut_iterator<T>* it2) {
  embed {
    return *it1 == *it2;
  }
}

public template <T>
void push_back(vector<T> mutable* v, T elem) {
  embed {
    v->push_back(std::move(elem));
  }
}

public template <T>
T* operator [](vector<T>* v, int index) {
  embed {
    return &v->at(index);
  }
}

public template <T>
T mutable* operator [](vector<T> mutable* v, int index) {
  embed {
    return &v->at(index);
  }
}

public template <T>
int size(vector<T>* v) {
  embed {
    return v->size();
  }
}

public template <T> requires comparable<T>
void sort(vector<T> mutable* v) {
  embed {
    std::sort(v->begin(), v->end());
  }
}

public template <T, int Sz>
vector<T> as_vector(mutable T[Sz] array) {
  mutable vector<T> ret;
  for (mutable it : array)
    embed {
    ret.push_back(std::move(*it.elem));
    }
  return move(ret);
}

public template <T>
T[] slice(vector<T>* v) {
  embed {
    return slice_t<T>{&v->front(), &v->back() + 1};
  }
}
